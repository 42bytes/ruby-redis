This project was started because I needed an authenticating and routable
proxy for Redis.  Special attention was paid to performance of the basic
Redis protocol.  All of the magic is in reader.rb.  This same parser can
be used for both clients and servers.

Performance considerations:

Ruby Redis uses cool.io for evented IO using libev.  An earlier version used
EventMachine but cool.io is faster in every benchmark.

Ruby 1.9.2 is the fastest in all benchmarks.  Ruby 1.8.7 is slower, but
usable.  Rubinius 1.2 and 2.0 did not perform well in any tests.  The
hiredis option is essential for Rubinius.

If the hiredis gem is compatible with your platform, you can use it for the 
client instead of the pure Ruby implementation.  It won't even double the
performance under Ruby 1.9, but it is faster in all cases (being C).

My laptop runs a ruby-redis server capable of 20k requests per second.
The client easily hits 40k requests per second.  An amazon c1.medium 32-bit
instance, using just one core (2.5 units), can handle more than 50Mbps.


Client Usage:

# To enable the optional hiredis reader, it only need be loaded
require 'hiredis/reader'

# Examples of the async interface
require 'redis'
redis = Redis.connect '127.0.0.1', 6379
# All commands implemented uniformly with method_missing
# Returns instance of Redis::Command < Deferrable 
# Pipelining is implicit
redis.set :pi, 3.14159
redis.get('pi') do |result|
  p result
end
redis.blpop('mylist', 0).callback do |result|
  p result
end.errback do |e|
  raise e
end
# Don't forget to start it on a loop
redis.attach Cool.io::Loop.default
Cool.io::Loop.default.run


# Fibers for blocking and transactions
require 'redis/fibers'
Redis.fiber(Redis.connect '127.0.0.1', 6379) do |redis| 
  redis.attach Cool.io::Loop.default
  reply = nil
  until reply
    # watch never fails, use pipeline
    redis.watch 'mykey' 
    # wait on the value we want to change
    x = redis.sync.get('mykey').to_i
    reply = redis.sync.multi_exec do |multi|
      # multi is pipelined (async)
      # no reason to block in here
      multi.set 'mykey', x + 1
    end
  end
  redis.close
end
Cool.io::Loop.default.run


Ruby <=> Redis type conversions:

#TODO