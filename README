This project was started because I needed an authenticating and routable
proxy for Redis.  Special attention was paid to performance of the basic
Redis protocol.  All of the magic is in buftok.rb.  This same parser can
be used for both clients and servers.

Which client gem should you use, 'redis' or 'ruby-redis'?  Use 'ruby-redis'
for EventMachine projects, and 'redis' if you're not using EventMachine.
Use 'ruby-redis' when you need a high-performance replace for hiredis/reader
in pure Ruby.

Performance considerations:

Ruby 1.9.2 is the fastest in all benchmarks.  Ruby 1.8 is slower, but
usable.  The client under JRuby performs well and should be faster than
any alternative. The server under JRuby performs poorly.  Rubinius 1.2
and 2.0 did not perform well in any tests.  The hiredis option is
essential for Rubinius.

If the hiredis gem is compatible with your platform, you can use it for the 
client instead of the pure Ruby implementation.  It won't double the
performance under Ruby 1.9, but it is faster in all cases (being pure C).

My laptop runs a ruby-redis server capable of up to 20k requests per
second performing GET and SET commands.  The client easily hits 40k
per second.  An amazon c1.medium 32-bit instance, using just one
core (2.5 compute units), can handle more than 50Mbps.


Client Usage:

# To enable the optional hiredis reader, it only need be loaded
require 'hiredis/reader'

# The only gem dependency is EventMachine unless you enable hiredis
require 'redis'
EM.run {
  redis = EventMachine.connect '127.0.0.1', 6379, Redis, :hiredis => true
  # Subscribe and publish messages will call here
  redis.pubsub_callback do |message|
    case message[0]
    when 'psubscribe' ...
  end
  # All commands implemented uniformly with method_missing
  # Returns instance of Redis::Command < EventMachine::Deferrable 
  # Pipelining is implicit
  redis.set :pi, 3.14159
  redis.get('pi') do |result|
    p result
  end
  redis.blpop('mylist', 0).callback do |result|
    p result
  end.errback do |e|
    raise e
  end
}

# Built-in support for Fibers; compatible with em-synchrony
require 'redis/synchrony'
Redis.synchrony {
  # Use redis to pipeline and sync to block
  redis = EventMachine.connect '127.0.0.1', 6379, Redis, :hiredis => true
  sync = redis.synchrony
  # repeat transaction until success
  reply = nil
  until reply
    redis.watch 'mykey' # never fails, use pipeline
    x = sync.get('mykey').to_i
    reply = sync.multi_exec do |multi|
      # multi is pipelined / async
      # do not use redis or sync in here
      multi.set 'mykey', x + 1
    end
  end
}


Ruby <=> Redis type conversions:

#TODO